/// \file ConjugacyDecomposition.hh Decomposition of finite groups into conjugacy classes

#ifndef CONJUGACYDECOMPOSITION_HH
#define CONJUGACYDECOMPOSITION_HH

#include "CayleyTable.hh"
#include "EquivalenceClasses.hh"
#include <random>

/// Analysis of <Enumerated Semigroup> into element orders
template<class G>
class OrdersDecomposition {
public:
    /// Constructor from <Enumerated Semigroup>
    OrdersDecomposition(const G& g = {}) {
        cycles.resize(g.getOrder());
        size_t i = 0;
        for(auto& e: g) {
            auto& v = cycles[i++];
            auto f = e;
            do {
                v.push_back(g.idx(f));
                f = g.apply(e, f);
            } while(f != e);
        }

        for(i = 0; i < cycles.size(); i++) by_order[cycles[i].size()].insert(i);
    }

    /// Display info
    void display(std::ostream& o = std::cout) {
        o << "Group with " << cycles.size() << " elements:\n";
        for(auto& kv: by_order) o << "\t" << kv.second.size() << " elements of order " << kv.first << "\n";
    }

    map<size_t,set<size_t>> by_order;       ///< elements (by index) grouped by order
    vector<vector<size_t>> cycles;          ///< cyclic groups generated by each element

    /// apply renumeration
    OrdersDecomposition& renumerate(const renumeration_t<>& m) {
        for(auto& kv: by_order) kv.second = renumerated(kv.second, m);
        for(auto& c: cycles) for(auto& x: c) x = m.at(x);
        cycles = renumerated_permute(cycles,m);
        return *this;
    }

    /// Get element inverse
    constexpr size_t inverse_idx(size_t i) const {
        auto& c = cycles[i];
        auto n = c.size();
        return n==1? c[0] : c[n-2];
    }
};

/// Analysis of <Enumerated Semigroup> into element orders and conjugacy classes
template<class G>
class ConjugacyDecomposition: public OrdersDecomposition<G> {
public:
    /// Constructor from <Enumerated Semigroup>
    ConjugacyDecomposition(const G& g = {}): OrdersDecomposition<G>(g) {
        for(auto& x: g) vscramble.push_back(x);

        std::shuffle(vscramble.begin(), vscramble.end(), std::mt19937(rand()));

        for(auto& os: this->by_order) {
            for(auto i: os.second) assign_CC(os.first, i, g);

            if(g.getOrder() > 1000) {
                std::cout << "Order " << os.first << ": ";
                for(auto& cc: M[os.first].CCs) std::cout << "(" << cc.second.size() << ") ";
                std::cout << std::endl;
            }

            repr_cosets.erase(os.first);
        }

        vscramble.clear();
    }

    /// Display info
    void display(std::ostream& o = std::cout) const {
        o << "Group with " << this->cycles.size() << " elements in conjugacy classes:\n";
        for(auto& kv: M)
            for(auto& ec: kv.second.CCs)
                o << "\t" << ec.second.size() << " elements\t[order " << kv.first << "]\n";
    }

    /// ``nicer'' re-enumeration scheme
    renumeration_t<> make_renumeration() const {
        renumeration_t<> m;
        size_t i = 0;
        for(auto& kv: M)
            for(auto& ec: kv.second.CCs)
                for(auto& e: ec.second)
                    m[e] = i++;
        return m;
    }

    /// apply renumeration
    ConjugacyDecomposition& renumerate(const renumeration_t<>& m) {
        OrdersDecomposition<G>::renumerate(m);
        for(auto& kv: M) kv.second.CCs.renumerate(m);
        return *this;
    }

    /// information on elements of a particular order
    struct oinfo {
        /// Conjugacy class decomposition for elements of this order
        EquivalenceClasses<size_t> CCs;
        /// powerup structure {order, conjclass} for each conjugacy class of this order
        vector<vector<pair<size_t,size_t>>> powerup;
    };
    map<size_t, oinfo> M;   ///< information by order

protected:
    vector<typename G::elem_t> vscramble;                       ///< scrambled search order
    map<size_t,vector<vector<typename G::enum_t>>> repr_cosets; ///< representative cosets for each class --- cleared after construction

    /// determine conj. class number to which element idx=i of order o belongs
    size_t assign_CC(size_t o, size_t i, const G& g) {
        auto& oi = M[o]; // already-identified conjugacy info for this order

        // already categorized?
        auto p = oi.CCs(i);
        if(p.first) return p.second;

        // check if element fits into any existing conjugacy class
        auto e = g.element(i);
        if(oi.CCs.size()) {
            size_t j = 0;
            for(auto& x: vscramble) {
                auto ixe = g.idx(g.apply(x, e));
                for(auto& CC: oi.CCs) {
                    if(ixe != repr_cosets[o][CC.first][j]) continue;

                    auto& pu = oi.powerup[CC.first];
                    if(pu.size()) {
                        // bulk assign all powers of this element if powerup structure already determined
                        size_t k = 0;
                        for(auto ii: this->cycles[i]) {
                            auto oc = pu[k++];
                            M[oc.first].CCs.addTo(ii, oc.second);
                        }
                    } else oi.CCs.addTo(i, CC.first); // only add this element

                    return CC.first;
                }
                j++;
            }
        }

        // start new conjugacy class
        auto n = oi.CCs.add(i,i);

        // build representative coset for class
        auto& vcs = repr_cosets[o];
        vcs.emplace_back();
        auto& cs = vcs.back();
        for(auto& x: vscramble) cs.push_back(g.idx(g.apply(e, x)));

        // build powerup structure
        assert(n == oi.powerup.size());
        oi.powerup.emplace_back();
        vector<pair<size_t,size_t>> pu(1, {o,n});
        for(auto ii: this->cycles[i]) {
            if(ii == i) continue;
            auto oo = this->cycles[ii].size();
            pu.emplace_back(oo, assign_CC(oo,ii,g));
        }
        oi.powerup[n] = pu;

        return n;
    }
};

/// Bundle of calculations resulting in conjugacy-enumerated elements
template<class G>
class GeneratorsConjugacy {
public:

    /// generators span type
    typedef GeneratorsSemigroup<G> genspan_t;
    /// Cayley Table type
    typedef CayleyTable<genspan_t> cayley_t;
    /// Conjugacy classes decomposition type
    typedef ConjugacyDecomposition<cayley_t> conjugacy_t;
    /// enumeration type
    typedef typename cayley_t::enum_t enum_t;

    /// Constructor
    explicit GeneratorsConjugacy(const vector<typename G::elem_t>& gs, const G& GG = {}): Rs(gs,GG) {
        renumerate(CD.make_renumeration());
    }

    /// apply renumeration
    void renumerate(const renumeration_t<enum_t>& m) {
        Rs.renumerate(m);
        CT.renumerate(m);
        CD.renumerate(m);
    }

    genspan_t Rs;       ///< generators span
    cayley_t CT{Rs};    ///< Cayley Table
    conjugacy_t CD{CT}; ///< Conjugacy relations
};

#endif
